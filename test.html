<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StructAlign — 構造アラインメント（ブラウザ内 / フォルダ対応）</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script src="https://unpkg.com/ngl@latest/dist/ngl.js"></script>
  <style>
    body { background: #ffffff; color: #111; }
    header { margin-top: 1rem; }
    .stage { width: 100%; height: 460px; background: #ffffff; border: 1px solid #e5e7eb; border-radius: 12px; }
    .muted { opacity: .8 }
    code.kbd { background:#f3f4f6; padding:.15rem .35rem; border-radius:6px }
    .err { color:#b00020; font-weight:600 }
    pre#logbox { background:#fafafa; border:1px solid #eee; padding:8px; max-height:200px; overflow:auto; font-size:12px }
    .btnrow { display:flex; gap:.5rem; align-items:center }
    table { white-space: nowrap; }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>StructAlign <small class="muted">— 構造アラインメント（Kabsch法・ブラウザ内）</small></h1>
      <p class="muted">テンプレート <code>.pdb</code> 1件 + 複数の <code>.pdb</code> を読み込みます。処理はすべてローカル（ブラウザ）で実行され、外部送信されません。</p>
    </header>

    <form id="form" onsubmit="alignSubmit(event)">
      <div class="grid">
        <label>テンプレート PDB（1件）
          <input type="file" name="pdb_target" accept=".pdb" required>
        </label>
        <label>アライン対象 PDB（フォルダ/複数可）
          <input type="file" name="pdb_mobile" accept=".pdb" multiple webkitdirectory>
        </label>
      </div>
      <div class="grid">
        <label>テンプレートのチェーン（カンマ区切り可: 例 A,B）
          <input name="chain_target" value="A,B" maxlength="50">
        </label>
        <label>対象のチェーン（カンマ区切り可: 例 A,B）
          <input name="chain_mobile" value="A,B" maxlength="50">
        </label>
      </div>
      <div class="grid">
        <label>チェーン対応
          <select name="chain_map_mode">
            <option value="fixed">固定（順番通りに対応）</option>
            <option value="auto2" selected>自動（二量体で最小RMSD）</option>
          </select>
        </label>
        <label>戦略（配列は使いません）
          <select name="match_strategy">
            <option value="resnum" selected>残基番号一致</option>
            <option value="index">インデックス順（CAの先頭N）</option>
          </select>
        </label>
        <label>原子集合
          <select name="atom_set">
            <option value="bb" selected>Backbone（N, CA, C, O）</option>
            <option value="ca">Cα のみ</option>
            <option value="heavy">重原子（H以外すべて）</option>
          </select>
        </label>
        <label>最低マッチ数
          <input name="min_pairs" type="number" value="12" min="3" max="100000">
        </label>
      </div>
      <div class="btnrow">
        <button type="submit">アラインメント実行</button>
        <button type="button" class="secondary" onclick="runDemo()">デモPDBで試す</button>
        <button type="button" class="secondary" onclick="toggleLog()">デバッグログ表示/非表示</button>
      </div>
    </form>

    <details id="logpanel" style="margin-top:6px; display:none">
      <summary>デバッグログ</summary>
      <pre id="logbox"></pre>
    </details>

    <article id="result" style="display:none">
      <h3>結果</h3>
      <p>
        <b>マッチ数:</b> <span id="matched">0</span>
        <b style="margin-left:1rem">RMSD (Å):</b> <span id="rmsd">–</span>
      </p>
      <section id="batchSection" style="display:none; margin:.5rem 0 1rem 0">
        <h5>複数ファイルの結果</h5>
        <div style="overflow:auto">
          <table>
            <thead>
              <tr>
                <th>ファイル名</th>
                <th>マッチ数</th>
                <th>RMSD (Å)</th>
                <th>操作</th>
              </tr>
            </thead>
            <tbody id="batchTbody"></tbody>
          </table>
        </div>
      </section>
      <div id="err" class="err"></div>
      <div class="grid">
        <div>
          <h4>テンプレート構造</h4>
          <div id="stageT" class="stage"></div>
        </div>
        <div>
          <h4>アライン後の対象構造</h4>
          <div id="stageM" class="stage"></div>
        </div>
      </div>
      <div>
        <button id="btnDownload" class="secondary">アライン後のPDBをダウンロード</button>
      </div>
      <p class="muted">ヒント: ビューア内で <code class="kbd">R</code> を押すとカメラ位置がリセットされます。</p>
    </article>

    <footer class="muted" style="margin:2rem 0">
      <small>© 2025 — <a href="https://github.com/arose/ngl" target="_blank" rel="noreferrer">NGL.js</a> を使用。データは外部へ送信されません。</small>
    </footer>
  </main>

<script>
/******************** ログ ********************/
function toggleLog(){ const p=document.getElementById('logpanel'); p.style.display = (p.style.display==='none')?'':'none'; }
function log(){ const box=document.getElementById('logbox'); box.textContent += Array.from(arguments).join(' ')+'\n'; }
function showError(msg){ const d=document.getElementById('err'); d.textContent = msg||''; if(msg) log('ERROR:', msg); }

/******************** PDB パーサ ********************/
function parsePDB(pdbText) {
  const atoms = []; // {name,resName,chainID,resSeq,iCode,x,y,z,element,line}
  const lines = pdbText.split(/\r?\n/);
  for (let i=0;i<lines.length;i++) {
    const line = lines[i];
    if (!line) continue;
    if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
      const name = line.slice(12,16).trim();
      const resName = line.slice(17,20).trim();
      const chainID = line.slice(21,22).trim() || ' ';
      const resSeq = parseInt(line.slice(22,26));
      const iCode = line.slice(26,27).trim();
      const x = parseFloat(line.slice(30,38));
      const y = parseFloat(line.slice(38,46));
      const z = parseFloat(line.slice(46,54));
      let element = line.length >= 78 ? line.slice(76,78).trim() : '';
      if(!element){ const c = name.trim()[0]; element = (c && c.toUpperCase()!=='H') ? c.toUpperCase() : 'H'; }
      atoms.push({ name, resName, chainID, resSeq, iCode, x, y, z, element, line });
    }
  }
  return atoms;
}

/******************** セレクタ（構造のみ） ********************/
function selectChainCA(atoms, chains) {
  const set = chains ? new Set(Array.isArray(chains)? chains : [chains]) : null;
  const list = [];
  const byKey = new Map();
  for (const a of atoms) {
    if (set && !set.has(a.chainID)) continue;
    if (a.name === 'CA') {
      const key = a.chainID + '|' + a.resSeq + ':' + a.iCode;
      const xyz = [a.x,a.y,a.z];
      list.push({ key, chainID:a.chainID, resSeq:a.resSeq, iCode:a.iCode, resName:a.resName, xyz: xyz });
      byKey.set(key, xyz);
    }
  }
  return { list, byKey };
}

function selectAtoms(atoms, chains, atomSet){
  const set = chains ? new Set(Array.isArray(chains)? chains : [chains]) : null;
  const list=[]; const map=new Map();
  const isBB = (n)=> n==='N' || n==='CA' || n==='C' || n==='O';
  for(const a of atoms){
    if(set && !set.has(a.chainID)) continue;
    if(atomSet==='ca' && a.name!=='CA') continue;
    if(atomSet==='bb' && !isBB(a.name)) continue;
    if(atomSet==='heavy' && a.element==='H') continue;
    const resKey = a.chainID + '|' + a.resSeq + ':' + a.iCode;
    const compKey = resKey + '|' + a.name;
    const xyz=[a.x,a.y,a.z];
    list.push({resKey, atomName:a.name, xyz});
    map.set(compKey, xyz);
  }
  return { list, map };
}

/******************** Kabsch（3x3 SVD） ********************/
function meanVec(P){ const n=P.length; return [0,1,2].map(k=>P.reduce((s,p)=>s+p[k],0)/n); }
function subVec(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function matMul(A,B){ const out=[[0,0,0],[0,0,0],[0,0,0]]; for(let i=0;i<3;i++) for(let j=0;j<3;j++) for(let k=0;k<3;k++) out[i][j]+=A[i][k]*B[k][j]; return out; }
function matVec(A,v){ return [A[0][0]*v[0]+A[0][1]*v[1]+A[0][2]*v[2], A[1][0]*v[0]+A[1][1]*v[1]+A[1][2]*v[2], A[2][0]*v[0]+A[2][1]*v[1]+A[2][2]*v[2]]; }

function svd3x3(M){
  function transpose(A){ return [[A[0][0],A[1][0],A[2][0]],[A[0][1],A[1][1],A[2][1]],[A[0][2],A[1][2],A[2][2]]]; }
  function matMul3(A,B){ return matMul(A,B); }
  const Mt = transpose(M);
  const MtM = matMul3(Mt,M);
  function eigSym3(A){
    let V=[[1,0,0],[0,1,0],[0,0,1]];
    let B=[[A[0][0],A[0][1],A[0][2]],[A[1][0],A[1][1],A[1][2]],[A[2][0],A[2][1],A[2][2]]];
    for(let iter=0; iter<32; iter++){
      let p=0,q=1; let max=Math.abs(B[0][1]); const pairs=[[0,1],[0,2],[1,2]];
      for(const [i,j] of pairs){ const v=Math.abs(B[i][j]); if(v>max){max=v;p=i;q=j;} }
      if(max<1e-12) break;
      const app=B[p][p], aqq=B[q][q], apq=B[p][q];
      const phi=0.5*Math.atan2(2*apq, (aqq-app));
      const c=Math.cos(phi), s=Math.sin(phi);
      const Rp=[[1,0,0],[0,1,0],[0,0,1]]; Rp[p][p]=c; Rp[q][q]=c; Rp[p][q]=s; Rp[q][p]=-s;
      const Rt=[[1,0,0],[0,1,0],[0,0,1]]; Rt[p][p]=c; Rt[q][q]=c; Rt[p][q]=-s; Rt[q][p]=s;
      B = matMul3(matMul3(Rt,B),Rp);
      V = matMul3(V,Rp);
    }
    return {vals:[B[0][0],B[1][1],B[2][2]], vecs:V};
  }
  const es = eigSym3(MtM);
  const Svals = es.vals.map(v=> Math.sqrt(Math.max(0,v)) );
  const V = [[es.vecs[0][0],es.vecs[0][1],es.vecs[0][2]],[es.vecs[1][0],es.vecs[1][1],es.vecs[1][2]],[es.vecs[2][0],es.vecs[2][1],es.vecs[2][2]]];
  const Sinv = [[ Svals[0]?1/Svals[0]:0,0,0 ],[0,Svals[1]?1/Svals[1]:0,0],[0,0,Svals[2]?1/Svals[2]:0]];
  const U = matMul(matMul(M,V),Sinv);
  return {U, S:Svals, Vt: transpose(V)};
}

function kabsch(P, Q){
  const Pc = meanVec(P), Qc = meanVec(Q);
  const X = P.map(p=>subVec(p,Pc));
  const Y = Q.map(q=>subVec(q,Qc));
  const H=[[0,0,0],[0,0,0],[0,0,0]];
  for(let i=0;i<X.length;i++){
    const x=X[i], y=Y[i];
    H[0][0]+=x[0]*y[0]; H[0][1]+=x[0]*y[1]; H[0][2]+=x[0]*y[2];
    H[1][0]+=x[1]*y[0]; H[1][1]+=x[1]*y[1]; H[1][2]+=x[1]*y[2];
    H[2][0]+=x[2]*y[0]; H[2][1]+=x[2]*y[1]; H[2][2]+=x[2]*y[2];
  }
  const {U, Vt} = svd3x3(H);
  const Rt=[[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]];
  let R = matMul(Vt, Rt);
  const det = R[0][0]*(R[1][1]*R[2][2]-R[1][2]*R[2][1]) - R[0][1]*(R[1][0]*R[2][2]-R[1][2]*R[2][0]) + R[0][2]*(R[1][0]*R[2][1]-R[1][1]*R[2][0]);
  if(det<0){ Vt[2][0]*=-1; Vt[2][1]*=-1; Vt[2][2]*=-1; R = matMul(Vt, Rt); }
  const t = [ Qc[0] - (R[0][0]*Pc[0]+R[0][1]*Pc[1]+R[0][2]*Pc[2]),
              Qc[1] - (R[1][0]*Pc[0]+R[1][1]*Pc[1]+R[1][2]*Pc[2]),
              Qc[2] - (R[2][0]*Pc[0]+R[2][1]*Pc[1]+R[2][2]*Pc[2]) ];
  return {R,t};
}
function rmsd(A,B){
  let s=0; for(let i=0;i<A.length;i++){ const dx=A[i][0]-B[i][0], dy=A[i][1]-B[i][1], dz=A[i][2]-B[i][2]; s+=dx*dx+dy*dy+dz*dz; }
  return Math.sqrt(s/A.length);
}

/******************** マッチング（構造のみ・多チェーン対応） ********************/
function matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM, chainMap){
  const T=[]; const M=[];
  function pushPairsCA(mapT, mapM){
    const keys = Array.from(mapT.keys()).filter(k=>mapM.has(k)).sort((a,b)=>{
      const ca=a.split('|')[0], cb=b.split('|')[0];
      const ai=parseInt(a.split('|')[1].split(':')[0]), bi=parseInt(b.split('|')[1].split(':')[0]);
      return ca.localeCompare(cb) || (ai-bi);
    });
    for(const k of keys){ T.push(mapT.get(k)); M.push(mapM.get(k)); }
  }
  function pushPairsAtoms(selT, selM){
    const keys = Array.from(selT.map.keys()).filter(k=>selM.map.has(k)).sort((a,b)=>{
      const ca=a.split('|')[0], cb=b.split('|')[0];
      const ia=a.split('|')[1], ib=b.split('|')[1];
      const na=a.split('|')[2], nb=b.split('|')[2];
      const ai=parseInt(ia.split(':')[0]), bi=parseInt(ib.split(':')[0]);
      const r=ca.localeCompare(cb) || (ai-bi); return r!==0 ? r : na.localeCompare(nb);
    });
    for(const k of keys){ T.push(selT.map.get(k)); M.push(selM.map.get(k)); }
  }
  for(const [ct, cm] of chainMap){
    if(strategy==='resnum'){
      if(atomSet==='ca'){
        const mapT = new Map(caT.list.filter(r=>r.chainID===ct).map(r=>[r.chainID+'|'+r.resSeq+':'+r.iCode, r.xyz]));
        const mapM = new Map(caM.list.filter(r=>r.chainID===cm).map(r=>[r.chainID+'|'+r.resSeq+':'+r.iCode, r.xyz]));
        pushPairsCA(mapT, mapM);
      }else{
        const selT = selectAtoms(atomsT, [ct], atomSet);
        const selM = selectAtoms(atomsM, [cm], atomSet);
        pushPairsAtoms(selT, selM);
      }
    } else if (strategy==='index'){
      const lt = caT.list.filter(r=>r.chainID===ct);
      const lm = caM.list.filter(r=>r.chainID===cm);
      const n = Math.min(lt.length, lm.length);
      for(let i=0;i<n;i++){ T.push(lt[i].xyz); M.push(lm[i].xyz); }
    }
  }
  return {T,M, count:T.length};
}

/******************** 変換 & 表示 ********************/
function transformPDB(atoms, R, t){
  function fmt8(val){ return val.toFixed(3).toString().padStart(8,' '); }
  const out = [];
  for(const a of atoms){
    const v=[a.x,a.y,a.z];
    const tv=[ R[0][0]*v[0]+R[0][1]*v[1]+R[0][2]*v[2]+t[0],
               R[1][0]*v[0]+R[1][1]*v[1]+R[1][2]*v[2]+t[1],
               R[2][0]*v[0]+R[2][1]*v[1]+R[2][2]*v[2]+t[2] ];
    let line = a.line;
    line = line.substring(0,30) + fmt8(tv[0]) + fmt8(tv[1]) + fmt8(tv[2]) + line.substring(54);
    out.push(line);
  }
  out.push('END');
  return out.join('\n');
}
function renderNGL(divId, pdbText, color){
  const stage = new NGL.Stage(divId, { backgroundColor: '#ffffff' });
  stage.removeAllComponents();
  const blob = new Blob([pdbText], {type:'text/plain'});
  stage.loadFile(blob, {ext:'pdb'}).then(c=>{
    c.addRepresentation('cartoon', {color, roughness:1.0});
    c.autoView();
  });
  return stage;
}

/******************** 実行コア（1対1） ********************/
function runAlignWithTexts(targText, mobText, opts){
  opts = opts||{}; showError(''); log('runAlignWithTexts start');
  const chainT_in = opts.chainT || ['A','B'];
  const chainM_in = opts.chainM || ['A','B'];
  const mapMode   = opts.mapMode || 'auto2';
  const strategy  = opts.strategy || 'resnum';
  const atomSet   = opts.atomSet || 'bb';
  const minPairs  = opts.minPairs || 12;

  const atomsT = parsePDB(targText);
  const atomsM = parsePDB(mobText);
  log('atomsT:', atomsT.length, 'atomsM:', atomsM.length);
  const caT = selectChainCA(atomsT, chainT_in);
  const caM = selectChainCA(atomsM, chainM_in);
  log('CA counts T:', caT.list.length, 'M:', caM.list.length);

  function attemptWithMap(chainMap){
    const res = matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM, chainMap);
    log('attempt map', JSON.stringify(chainMap), 'pairs=', res.count);
    if(res.count < Math.max(3,minPairs)) return {ok:false};
    const tr = kabsch(res.M, res.T);
    const MT = res.M.map(v=> [ tr.R[0][0]*v[0]+tr.R[0][1]*v[1]+tr.R[0][2]*v[2]+tr.t[0],
                                tr.R[1][0]*v[0]+tr.R[1][1]*v[1]+tr.R[1][2]*v[2]+tr.t[1],
                                tr.R[2][0]*v[0]+tr.R[2][1]*v[1]+tr.R[2][2]*v[2]+tr.t[2] ]);
    const r = rmsd(MT, res.T);
    return {ok:true, R:tr.R, t:tr.t, count:res.count, rmsd:r};
  }

  let best = null, usedMap = null;
  if(mapMode==='auto2' && chainT_in.length===2 && chainM_in.length===2){
    const maps = [ [[chainT_in[0], chainM_in[0]],[chainT_in[1], chainM_in[1]]],
                   [[chainT_in[0], chainM_in[1]],[chainT_in[1], chainM_in[0]]] ];
    for(const m of maps){ const rs = attemptWithMap(m); if(rs.ok && (!best || rs.rmsd<best.rmsd)){ best=rs; usedMap=m; } }
  } else {
    const zipped=[]; for(let i=0; i<Math.min(chainT_in.length, chainM_in.length); i++){ zipped.push([chainT_in[i], chainM_in[i]]); }
    const m2 = zipped.length? zipped : [[chainT_in[0]||'A', chainM_in[0]||'A']];
    const rs2 = attemptWithMap(m2); if(rs2.ok){ best=rs2; usedMap=m2; }
  }

  if(!best){ showError('マッチ数が不足、またはチェーン対応が不正です。チェーン指定・戦略・原子集合を見直してください。'); return false; }

  const alignedPDBTextLocal = transformPDB(atomsM, best.R, best.t);
  document.getElementById('matched').textContent = best.count;
  document.getElementById('rmsd').textContent = best.rmsd.toFixed(3);
  document.getElementById('result').style.display = '';
  renderNGL('stageT', targText, 0x2196f3);
  renderNGL('stageM', alignedPDBTextLocal, 0xff7043);
  alignedPDBText = alignedPDBTextLocal;
  log('done. rmsd=', best.rmsd.toFixed(3));
  return true;
}

/******************** UIハンドラ（フォルダ/複数） ********************/
let alignedPDBText='';
let _alignedMap = {}; // filename -> {text, rmsd, count}

async function alignSubmit(ev){
  ev.preventDefault(); showError('');
  try{
    const fd = new FormData(document.getElementById('form'));
    const targetInput = document.querySelector('input[name="pdb_target"]');
    const mobileInput = document.querySelector('input[name="pdb_mobile"]');
    const targetFile = targetInput && targetInput.files[0];
    let mobileFiles = mobileInput ? Array.from(mobileInput.files||[]) : [];
    mobileFiles = mobileFiles.filter(f=>/\.pdb$/i.test(f.name));
    if(!targetFile || mobileFiles.length===0){ showError('テンプレートPDB 1件と対象PDB（1件以上）を選択してください'); return; }

    const chainT_in = (fd.get('chain_target')||'A').split(',').map(s=>s.trim()).filter(Boolean);
    const chainM_in = (fd.get('chain_mobile')||'A').split(',').map(s=>s.trim()).filter(Boolean);
    const mapMode = fd.get('chain_map_mode')||'auto2';
    const strategy = fd.get('match_strategy')||'resnum';
    const atomSet  = fd.get('atom_set')||'bb';
    const minPairs = parseInt(fd.get('min_pairs')||'12', 10);

    const targText = await targetFile.text();
    // 先にテンプレートを描画
    document.getElementById('result').style.display = '';
    renderNGL('stageT', targText, 0x2196f3);

    // テーブル初期化
    _alignedMap = {}; const tbody=document.getElementById('batchTbody'); tbody.innerHTML='';
    document.getElementById('batchSection').style.display='';

    // チェーン対応候補のビルド
    function candidateMaps(){
      if(mapMode==='auto2' && chainT_in.length===2 && chainM_in.length===2){
        return [
          [[chainT_in[0],chainM_in[0]],[chainT_in[1],chainM_in[1]]],
          [[chainT_in[0],chainM_in[1]],[chainT_in[1],chainM_in[0]]]
        ];
      }
      const zipped=[]; const n=Math.min(chainT_in.length, chainM_in.length);
      for(let i=0;i<n;i++) zipped.push([chainT_in[i], chainM_in[i]]);
      return [zipped.length?zipped:[[chainT_in[0]||'A', chainM_in[0]||'A']]];
    }

    // 各ファイルを順次処理
    for (const f of mobileFiles){
      const mobText = await f.text();
      const atomsT = parsePDB(targText);
      const atomsM = parsePDB(mobText);
      const caT = selectChainCA(atomsT, null);
      const caM = selectChainCA(atomsM, null);

      let best=null;
      for(const cmap of candidateMaps()){
        const res = matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM, cmap);
        if(res.count < Math.max(3,minPairs)) continue;
        const tr = kabsch(res.M, res.T);
        const MT = res.M.map(v=> [ tr.R[0][0]*v[0]+tr.R[0][1]*v[1]+tr.R[0][2]*v[2]+tr.t[0],
                                    tr.R[1][0]*v[0]+tr.R[1][1]*v[1]+tr.R[1][2]*v[2]+tr.t[1],
                                    tr.R[2][0]*v[0]+tr.R[2][1]*v[1]+tr.R[2][2]*v[2]+tr.t[2] ]);
        const r = rmsd(MT, res.T);
        const pack = {R:tr.R, t:tr.t, count:res.count, rmsd:r};
        if(!best || r<best.rmsd) best=pack;
      }

      if(best){
        const aligned = transformPDB(atomsM, best.R, best.t);
        _alignedMap[f.name] = { text: aligned, rmsd: best.rmsd, count: best.count };
        const trEl=document.createElement('tr');
        trEl.innerHTML = `<td>${f.webkitRelativePath || f.name}</td><td>${best.count}</td><td>${best.rmsd.toFixed(3)}</td>
          <td>
            <button type="button" class="secondary btnShow">表示</button>
            <button type="button" class="secondary btnDL">DL</button>
          </td>`;
        trEl.querySelector('.btnShow').addEventListener('click', function(){
          renderNGL('stageM', aligned, 0xff7043);
          document.getElementById('matched').textContent = best.count;
          document.getElementById('rmsd').textContent = best.rmsd.toFixed(3);
          alignedPDBText = aligned;
        });
        trEl.querySelector('.btnDL').addEventListener('click', function(){
          const blob = new Blob([aligned], {type:'chemical/x-pdb'});
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = (f.name.replace(/\.pdb$/i,'') + '_aligned.pdb');
          a.click();
          URL.revokeObjectURL(a.href);
        });
        tbody.appendChild(trEl);
        if(Object.keys(_alignedMap).length===1){ trEl.querySelector('.btnShow').click(); } // 最初は自動プレビュー
      } else {
        const trEl=document.createElement('tr');
        trEl.innerHTML = `<td>${f.webkitRelativePath || f.name}</td><td colspan="3" class="err">マッチ数が不足（残基番号/原子セット/チェーンを確認）</td>`;
        tbody.appendChild(trEl);
      }
    }
  }catch(e){ console.error(e); showError('実行時エラー: '+ (e && e.message? e.message: e)); }
}

/******************** デモ ********************/
function runDemo(){
  // 最小の二量体デモ（A,Bチェーンで同一座標、モバイルは少し平行移動）
  const pdbT = [
    'ATOM      1  N   ALA A   1       0.000   0.000   0.000  1.00 20.00           N',
    'ATOM      2  CA  ALA A   1       1.458   0.000   0.000  1.00 20.00           C',
    'ATOM      3  C   ALA A   1       2.000   1.300   0.000  1.00 20.00           C',
    'ATOM      4  O   ALA A   1       1.500   2.300   0.000  1.00 20.00           O',
    'ATOM      5  N   ALA B   1       0.000   5.000   0.000  1.00 20.00           N',
    'ATOM      6  CA  ALA B   1       1.458   5.000   0.000  1.00 20.00           C',
    'ATOM      7  C   ALA B   1       2.000   6.300   0.000  1.00 20.00           C',
    'ATOM      8  O   ALA B   1       1.500   7.300   0.000  1.00 20.00           O',
    'END'
  ].join('\n');
  const pdbM = [
    'ATOM      1  N   ALA A   1       3.000   0.500   0.200  1.00 20.00           N',
    'ATOM      2  CA  ALA A   1       4.458   0.500   0.200  1.00 20.00           C',
    'ATOM      3  C   ALA A   1       5.000   1.800   0.200  1.00 20.00           C',
    'ATOM      4  O   ALA A   1       4.500   2.800   0.200  1.00 20.00           O',
    'ATOM      5  N   ALA B   1       3.000   5.500   0.200  1.00 20.00           N',
    'ATOM      6  CA  ALA B   1       4.458   5.500   0.200  1.00 20.00           C',
    'ATOM      7  C   ALA B   1       5.000   6.800   0.200  1.00 20.00           C',
    'ATOM      8  O   ALA B   1       4.500   7.800   0.200  1.00 20.00           O',
    'END'
  ].join('\n');
  document.querySelector('input[name="chain_target"]').value='A,B';
  document.querySelector('input[name="chain_mobile"]').value='A,B';
  document.querySelector('select[name="chain_map_mode"]').value='auto2';
  document.querySelector('select[name="match_strategy"]').value='resnum';
  document.querySelector('select[name="atom_set"]').value='bb';
  document.querySelector('input[name="min_pairs"]').value='4';
  toggleLog();
  runAlignWithTexts(pdbT, pdbM, { chainT:['A','B'], chainM:['A','B'], mapMode:'auto2', strategy:'resnum', atomSet:'bb', minPairs:4 });
}

/******************** ダウンロード *************************/
document.getElementById('btnDownload').addEventListener('click', ()=>{
  if(!alignedPDBText){ alert('先にアラインメントを実行してください'); return; }
  const blob = new Blob([alignedPDBText], {type:'chemical/x-pdb'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'mobile_aligned.pdb';
  a.click();
  URL.revokeObjectURL(a.href);
});
</script>
</body>
</html>

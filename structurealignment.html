<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StructAlign — ブラウザでのPDBアラインメント</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script src="https://unpkg.com/ngl@latest/dist/ngl.js"></script>
  <style>
    body { background: #ffffff; color: #111; }
    header { margin-top: 1rem; }
    .stage { width: 100%; height: 460px; background: #ffffff; border: 1px solid #e5e7eb; border-radius: 12px; }
    .muted { opacity: .8 }
    code.kbd { background:#f3f4f6; padding:.15rem .35rem; border-radius:6px }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>StructAlign <small class="muted">— ブラウザ内での構造アラインメント (Kabsch法)</small></h1>
      <p class="muted">2つの <code>.pdb</code> ファイルを読み込みます。処理はすべてローカル（ブラウザ）で実行され、サーバーへ送信されません。</p>
    </header>

    <form id="form" onsubmit="alignSubmit(event)">
      <div class="grid">
        <label>テンプレート PDB
          <input type="file" name="pdb_target" accept=".pdb" required>
        </label>
        <label>アライン対象 PDB
          <input type="file" name="pdb_mobile" accept=".pdb" required>
        </label>
      </div>
      <div class="grid">
        <label>テンプレートのチェーン
          <input name="chain_target" value="A" maxlength="2">
        </label>
        <label>対象のチェーン
          <input name="chain_mobile" value="A" maxlength="2">
        </label>
      </div>
      <details open>
        <summary>詳細設定</summary>
        <small class="muted">高相同性どうしは「残基番号が一致」+「Backbone」推奨です。</small>
        <div class="grid">
          <label>
            戦略
            <select name="match_strategy">
              <option value="seq">配列アラインメント（簡易グローバル）</option>
              <option value="resnum" selected>残基番号が一致するもの</option>
              <option value="index">先頭N残基の順番</option>
            </select>
          </label>
          <label>
            原子集合
            <select name="atom_set">
              <option value="bb" selected>Backbone（N, CA, C, O）</option>
              <option value="ca">Cα のみ</option>
              <option value="heavy">重原子（H以外すべて）</option>
            </select>
          </label>
          <label>
            最低マッチ数
            <input name="min_pairs" type="number" value="12" min="3" max="100000">
          </label>
        </div>
      </details>
      <button type="submit">アラインメント実行</button>
    </form>

    <article id="result" style="display:none">
      <h3>結果</h3>
      <p>
        <b>マッチ数:</b> <span id="matched">0</span>
        <b style="margin-left:1rem">RMSD (Å):</b> <span id="rmsd">–</span>
      </p>
      <div class="grid">
        <div>
          <h4>テンプレート構造</h4>
          <div id="stageT" class="stage"></div>
        </div>
        <div>
          <h4>アライン後の対象構造</h4>
          <div id="stageM" class="stage"></div>
        </div>
      </div>
      <div>
        <button id="btnDownload" class="secondary">アライン後のPDBをダウンロード</button>
      </div>
      <p class="muted">ヒント: ビューア内で <code class="kbd">R</code> を押すとカメラ位置がリセットされます。</p>
    </article>

    <footer class="muted" style="margin:2rem 0">
      <small>© 2025 — <a href="https://github.com/arose/ngl" target="_blank" rel="noreferrer">NGL.js</a> を使用。データは外部へ送信されません。</small>
    </footer>
  </main>

<script>
// ========== PDB パーサ ==========
function parsePDB(pdbText) {
  const atoms = []; // {name,resName,chainID,resSeq,iCode,x,y,z,element,line}
  const lines = pdbText.split(/\r?\n/);
  for (const line of lines) {
    if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
      const name = line.slice(12,16).trim();
      const resName = line.slice(17,20).trim();
      const chainID = line.slice(21,22).trim() || ' ';
      const resSeq = parseInt(line.slice(22,26));
      const iCode = line.slice(26,27).trim();
      const x = parseFloat(line.slice(30,38));
      const y = parseFloat(line.slice(38,46));
      const z = parseFloat(line.slice(46,54));
      let element = line.length >= 78 ? line.slice(76,78).trim() : '';
      if(!element){ const c = name.trim()[0]; element = (c && c.toUpperCase()!=='H') ? c.toUpperCase() : 'H'; }
      atoms.push({ name, resName, chainID, resSeq, iCode, x, y, z, element, line });
    }
  }
  return atoms;
}

function selectChainCA(atoms, chainID) {
  const ca = [];
  const byKey = new Map();
  for (const a of atoms) {
    if (chainID && a.chainID !== chainID) continue;
    if (a.name === 'CA') {
      const key = `${a.resSeq}:${a.iCode}`;
      ca.push({ key, resSeq:a.resSeq, iCode:a.iCode, resName:a.resName, chainID:a.chainID, xyz:[a.x,a.y,a.z] });
      byKey.set(key, [a.x,a.y,a.z]);
    }
  }
  return { list: ca, byKey };
}

function selectAtoms(atoms, chainID, atomSet){
  // { resKey, atomName, xyz } のリストと、resKey|atomName → 座標 のMap
  const list=[]; const map=new Map();
  const isBB = (n)=> n==='N' || n==='CA' || n==='C' || n==='O';
  for(const a of atoms){
    if(chainID && a.chainID!==chainID) continue;
    if(atomSet==='ca' && a.name!=='CA') continue;
    if(atomSet==='bb' && !isBB(a.name)) continue;
    if(atomSet==='heavy' && a.element==='H') continue;
    const resKey = `${a.resSeq}:${a.iCode}`;
    const compKey = `${resKey}|${a.name}`;
    list.push({resKey, atomName:a.name, xyz:[a.x,a.y,a.z]});
    map.set(compKey, [a.x,a.y,a.z]);
  }
  return { list, map };
}

const threeToOne = { ALA:'A', ARG:'R', ASN:'N', ASP:'D', CYS:'C', GLU:'E', GLN:'Q', GLY:'G', HIS:'H', ILE:'I', LEU:'L', LYS:'K', MET:'M', PHE:'F', PRO:'P', SER:'S', THR:'T', TRP:'W', TYR:'Y', VAL:'V', SEC:'U', PYL:'O' };
function seqFromCA(list) { return list.map(r => (threeToOne[r.resName] || 'X')).join(''); }

// ========== 簡易NW配列アラインメント（CA用） ==========
function needlemanWunsch(a, b, {match=2, mismatch=-1, gap=-2}={}) {
  const n=a.length, m=b.length;
  const dp = Array.from({length:n+1},()=>Array(m+1).fill(0));
  const bt = Array.from({length:n+1},()=>Array(m+1).fill(0)); // 0:diag, 1:up, 2:left
  for(let i=1;i<=n;i++){ dp[i][0]=i*gap; bt[i][0]=1; }
  for(let j=1;j<=m;j++){ dp[0][j]=j*gap; bt[0][j]=2; }
  for(let i=1;i<=n;i++){
    for(let j=1;j<=m;j++){
      const scoreDiag = dp[i-1][j-1] + (a[i-1]===b[j-1]?match:mismatch);
      const scoreUp = dp[i-1][j] + gap;
      const scoreLeft = dp[i][j-1] + gap;
      const maxv = Math.max(scoreDiag, scoreUp, scoreLeft);
      dp[i][j]=maxv;
      bt[i][j] = (maxv===scoreDiag)?0:(maxv===scoreUp?1:2);
    }
  }
  let i=n, j=m; const A=[], B=[];
  while(i>0 || j>0){
    const move = bt[i][j];
    if (i>0 && j>0 && move===0){ A.push(a[i-1]); B.push(b[j-1]); i--; j--; }
    else if (i>0 && (j===0 || move===1)){ A.push(a[i-1]); B.push('-'); i--; }
    else { A.push('-'); B.push(b[j-1]); j--; }
  }
  return { a:A.reverse().join(''), b:B.reverse().join('') };
}

// ========== Kabsch ==========
function meanVec(P){ const n=P.length; return [0,1,2].map(k=>P.reduce((s,p)=>s+p[k],0)/n); }
function subVec(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function matMul(A,B){ const out=[[0,0,0],[0,0,0],[0,0,0]]; for(let i=0;i<3;i++) for(let j=0;j<3;j++) for(let k=0;k<3;k++) out[i][j]+=A[i][k]*B[k][j]; return out; }
function matVec(A,v){ return [A[0][0]*v[0]+A[0][1]*v[1]+A[0][2]*v[2], A[1][0]*v[0]+A[1][1]*v[1]+A[1][2]*v[2], A[2][0]*v[0]+A[2][1]*v[1]+A[2][2]*v[2]]; }
function svd3x3(M){
  function transpose(A){ return [[A[0][0],A[1][0],A[2][0]],[A[0][1],A[1][1],A[2][1]],[A[0][2],A[1][2],A[2][2]]]; }
  function matMul3(A,B){ return matMul(A,B); }
  const Mt = transpose(M); const MtM = matMul3(Mt,M);
  function eigSym3(A){
    let V=[[1,0,0],[0,1,0],[0,0,1]]; let B=[[...A[0]],[...A[1]],[...A[2]]];
    for(let iter=0; iter<32; iter++){
      let p=0,q=1; let max=Math.abs(B[0][1]);
      const pairs=[[0,1],[0,2],[1,2]];
      for(const [i,j] of pairs){ const v=Math.abs(B[i][j]); if(v>max){max=v;p=i;q=j;} }
      if(max<1e-12) break;
      const app=B[p][p], aqq=B[q][q], apq=B[p][q];
      const phi=0.5*Math.atan2(2*apq, (aqq-app));
      const c=Math.cos(phi), s=Math.sin(phi);
      const Rp=[[1,0,0],[0,1,0],[0,0,1]]; Rp[p][p]=c; Rp[q][q]=c; Rp[p][q]=s; Rp[q][p]=-s;
      const Rt=[[1,0,0],[0,1,0],[0,0,1]]; Rt[p][p]=c; Rt[q][q]=c; Rt[p][q]=-s; Rt[q][p]=s;
      B = matMul3(matMul3(Rt,B),Rp);
      V = matMul3(V,Rp);
    }
    const vals=[B[0][0],B[1][1],B[2][2]]; return {vals, vecs:V};
  }
  const {vals, vecs} = eigSym3(MtM);
  const Svals = vals.map(v=> Math.sqrt(Math.max(0,v)) );
  const V = [[vecs[0][0],vecs[0][1],vecs[0][2]],[vecs[1][0],vecs[1][1],vecs[1][2]],[vecs[2][0],vecs[2][1],vecs[2][2]]];
  const Sinv = [[ Svals[0]?1/Svals[0]:0,0,0 ],[0,Svals[1]?1/Svals[1]:0,0],[0,0,Svals[2]?1/Svals[2]:0]];
  const U = matMul(matMul(M,V),Sinv);
  return {U, S:Svals, Vt: transpose(V)};
}
function kabsch(P, Q){
  const Pc = meanVec(P), Qc = meanVec(Q);
  const X = P.map(p=>subVec(p,Pc));
  const Y = Q.map(q=>subVec(q,Qc));
  const H=[[0,0,0],[0,0,0],[0,0,0]];
  for(let i=0;i<X.length;i++){
    const x=X[i], y=Y[i];
    H[0][0]+=x[0]*y[0]; H[0][1]+=x[0]*y[1]; H[0][2]+=x[0]*y[2];
    H[1][0]+=x[1]*y[0]; H[1][1]+=x[1]*y[1]; H[1][2]+=x[1]*y[2];
    H[2][0]+=x[2]*y[0]; H[2][1]+=x[2]*y[1]; H[2][2]+=x[2]*y[2];
  }
  const {U, Vt} = svd3x3(H);
  let R = matMul(Vt, [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]]);
  const det = R[0][0]*(R[1][1]*R[2][2]-R[1][2]*R[2][1]) - R[0][1]*(R[1][0]*R[2][2]-R[1][2]*R[2][0]) + R[0][2]*(R[1][0]*R[2][1]-R[1][1]*R[2][0]);
  if(det<0){ Vt[2][0]*=-1; Vt[2][1]*=-1; Vt[2][2]*=-1; R = matMul(Vt, [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]]); }
  const t = [ Qc[0] - (R[0][0]*Pc[0]+R[0][1]*Pc[1]+R[0][2]*Pc[2]),
              Qc[1] - (R[1][0]*Pc[0]+R[1][1]*Pc[1]+R[1][2]*Pc[2]),
              Qc[2] - (R[2][0]*Pc[0]+R[2][1]*Pc[1]+R[2][2]*Pc[2]) ];
  return {R,t};
}
function rmsd(A,B){ let s=0; for(let i=0;i<A.length;i++){ const dx=A[i][0]-B[i][0]; const dy=A[i][1]-B[i][1]; const dz=A[i][2]-B[i][2]; s+=dx*dx+dy*dy+dz*dz; } return Math.sqrt(s/A.length); }

// ========== ペア構築 ==========
function matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM){
  if (strategy==='resnum'){
    if(atomSet==='ca'){
      const mapT = new Map(caT.list.map(r=>[r.key, r]));
      const mapM = new Map(caM.list.map(r=>[r.key, r]));
      const common = [...mapT.keys()].filter(k=>mapM.has(k)).sort((a,b)=>{
        const ai=parseInt(a.split(':')[0]), bi=parseInt(b.split(':')[0]); return ai-bi; });
      const T=[], M=[]; for(const k of common){ T.push(mapT.get(k).xyz); M.push(mapM.get(k).xyz); }
      return {T,M, count:T.length};
    }
    // Backbone / Heavy: 残基番号 + 原子名で一致
    const chainT = caT.list[0]?.chainID || null;
    const chainM = caM.list[0]?.chainID || null;
    const selT = selectAtoms(atomsT, chainT, atomSet);
    const selM = selectAtoms(atomsM, chainM, atomSet);
    const keysT = [...selT.map.keys()];
    const common = keysT.filter(k=>selM.map.has(k)).sort((a,b)=>{
      const [ra,na]=a.split('|'); const [rb,nb]=b.split('|');
      const ai=parseInt(ra.split(':')[0]), bi=parseInt(rb.split(':')[0]);
      return (ai-bi) || na.localeCompare(nb);
    });
    const T=[], M=[]; for(const k of common){ T.push(selT.map.get(k)); M.push(selM.map.get(k)); }
    return {T,M, count:T.length};
  }
  if (strategy==='index'){
    const n = Math.min(caT.list.length, caM.list.length);
    const T=[], M=[]; for(let i=0;i<n;i++){ T.push(caT.list[i].xyz); M.push(caM.list[i].xyz);} 
    return {T,M, count:n};
  }
  // デフォルト: 配列アラインメント（CAのみ）
  const seqT = seqFromCA(caT.list);
  const seqM = seqFromCA(caM.list);
  const aln = needlemanWunsch(seqT, seqM, {match:2, mismatch:-1, gap:-2});
  let iT=0, iM=0; const T=[], M=[];
  for(let k=0;k<aln.a.length;k++){
    const a=aln.a[k], b=aln.b[k];
    if(a!=='-' && b!=='-'){ T.push(caT.list[iT].xyz); M.push(caM.list[iM].xyz); }
    if(a!=='-') iT++; if(b!=='-') iM++;
  }
  return {T,M, count:T.length};
}

// ========== PDB座標の書き換え ==========
function transformPDB(atoms, R, t){
  function fmt8(val){ return val.toFixed(3).toString().padStart(8,' '); }
  const out = [];
  for(const a of atoms){
    const v=[a.x,a.y,a.z];
    const tv=[ R[0][0]*v[0]+R[0][1]*v[1]+R[0][2]*v[2]+t[0],
               R[1][0]*v[0]+R[1][1]*v[1]+R[1][2]*v[2]+t[1],
               R[2][0]*v[0]+R[2][1]*v[1]+R[2][2]*v[2]+t[2] ];
    let line = a.line;
    line = line.substring(0,30) + fmt8(tv[0]) + fmt8(tv[1]) + fmt8(tv[2]) + line.substring(54);
    out.push(line);
  }
  out.push('END');
  return out.join('\n');
}

// ========== NGL 表示 ==========
function renderNGL(divId, pdbText, color){
  const stage = new NGL.Stage(divId, { backgroundColor: '#ffffff' });
  stage.removeAllComponents();
  const blob = new Blob([pdbText], {type:'text/plain'});
  stage.loadFile(blob, {ext:'pdb'}).then(c=>{
    c.addRepresentation('cartoon', {color, roughness:1.0});
    c.autoView();
  });
  return stage;
}

// ========== 実行ハンドラ ==========
let alignedPDBText='';
async function alignSubmit(ev){
  ev.preventDefault(); // ← これが無いとフォーム送信でページがリロードされてしまいます
  const fd = new FormData(document.getElementById('form'));
  const targetFile = fd.get('pdb_target');
  const mobileFile = fd.get('pdb_mobile');
  if(!targetFile || !mobileFile){ alert('PDBファイルを選択してください'); return; }

  const chainT = (fd.get('chain_target')||'A').trim() || 'A';
  const chainM = (fd.get('chain_mobile')||'A').trim() || 'A';
  const strategy = fd.get('match_strategy') || 'resnum';
  const atomSet = (fd.get('atom_set')||'bb');
  const minPairs = parseInt(fd.get('min_pairs')||'12');

  const targText = await targetFile.text();
  const mobText  = await mobileFile.text();
  const atomsT = parsePDB(targText);
  const atomsM = parsePDB(mobText);
  const caT = selectChainCA(atomsT, chainT);
  const caM = selectChainCA(atomsM, chainM);

  const {T, M, count} = matchPairs(
    strategy, caT, caM, atomSet,
    atomsT.filter(a=>!chainT||a.chainID===chainT),
    atomsM.filter(a=>!chainM||a.chainID===chainM)
  );

  if(count < Math.max(3,minPairs)){
    alert(`マッチ数が不足しています: ${count} （設定値: ${minPairs}）\nチェーン/戦略/原子集合を見直してください。`);
    return;
  }

  const {R,t} = kabsch(M, T);
  const MT = M.map(v=> [ R[0][0]*v[0]+R[0][1]*v[1]+R[0][2]*v[2]+t[0],
                         R[1][0]*v[0]+R[1][1]*v[1]+R[1][2]*v[2]+t[1],
                         R[2][0]*v[0]+R[2][1]*v[1]+R[2][2]*v[2]+t[2] ]);
  const currentRMSD = rmsd(MT, T);
  alignedPDBText = transformPDB(atomsM, R, t);

  document.getElementById('matched').textContent = count;
  document.getElementById('rmsd').textContent = currentRMSD.toFixed(3);
  document.getElementById('result').style.display = '';

  renderNGL('stageT', targText, 0x2196f3);
  renderNGL('stageM', alignedPDBText, 0xff7043);
}

// ダウンロード
const btn = document.getElementById('btnDownload');
btn.addEventListener('click', ()=>{
  if(!alignedPDBText){ alert('先にアラインメントを実行してください'); return; }
  const blob = new Blob([alignedPDBText], {type:'chemical/x-pdb'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'mobile_aligned.pdb';
  a.click();
  URL.revokeObjectURL(a.href);
});
</script>
</body>
</html>

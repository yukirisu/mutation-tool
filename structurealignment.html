<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StructAlign — ブラウザでのPDBアラインメント（二量体対応）</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script src="https://unpkg.com/ngl@latest/dist/ngl.js"></script>
  <style>
    body { background: #ffffff; color: #111; }
    header { margin-top: 1rem; }
    .stage { width: 100%; height: 460px; background: #ffffff; border: 1px solid #e5e7eb; border-radius: 12px; }
    .muted { opacity: .8 }
    code.kbd { background:#f3f4f6; padding:.15rem .35rem; border-radius:6px }
    .err { color:#b00020; font-weight:600 }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>StructAlign <small class="muted">— ブラウザ内での構造アラインメント (Kabsch法)v2</small></h1>
      <p class="muted">2つの <code>.pdb</code> ファイルを読み込みます。処理はすべてローカル（ブラウザ）で実行され、サーバーへ送信されません。</p>
    </header>

    <form id="form" onsubmit="alignSubmit(event)">
      <div class="grid">
        <label>テンプレート PDB
          <input type="file" name="pdb_target" accept=".pdb" required>
        </label>
        <label>アライン対象 PDB
          <input type="file" name="pdb_mobile" accept=".pdb" required>
        </label>
      </div>
      <div class="grid">
        <label>テンプレートのチェーン（カンマ区切り可: 例 A,B）
          <input name="chain_target" value="A,B" maxlength="20">
        </label>
        <label>対象のチェーン（カンマ区切り可: 例 A,B）
          <input name="chain_mobile" value="A,B" maxlength="20">
        </label>
      </div>
      <div class="grid">
        <label>チェーン対応
          <select name="chain_map_mode">
            <option value="fixed">固定（順番通りに対応）</option>
            <option value="auto2" selected>自動（二量体で最小RMSD）</option>
          </select>
        </label>
      </div>
      <details open>
        <summary>詳細設定</summary>
        <small class="muted">高相同性どうしは「残基番号が一致」+「Backbone」推奨です。</small>
        <div class="grid">
          <label>
            戦略
            <select name="match_strategy">
              <option value="seq">配列アラインメント（簡易グローバル）</option>
              <option value="resnum" selected>残基番号が一致するもの</option>
              <option value="index">先頭N残基の順番</option>
            </select>
          </label>
          <label>
            原子集合
            <select name="atom_set">
              <option value="bb" selected>Backbone（N, CA, C, O）</option>
              <option value="ca">Cα のみ</option>
              <option value="heavy">重原子（H以外すべて）</option>
            </select>
          </label>
          <label>
            最低マッチ数
            <input name="min_pairs" type="number" value="12" min="3" max="100000">
          </label>
        </div>
      </details>
      <button type="submit">アラインメント実行</button>
    </form>

    <article id="result" style="display:none">
      <h3>結果</h3>
      <p>
        <b>マッチ数:</b> <span id="matched">0</span>
        <b style="margin-left:1rem">RMSD (Å):</b> <span id="rmsd">–</span>
      </p>
      <div id="err" class="err"></div>
      <div class="grid">
        <div>
          <h4>テンプレート構造</h4>
          <div id="stageT" class="stage"></div>
        </div>
        <div>
          <h4>アライン後の対象構造</h4>
          <div id="stageM" class="stage"></div>
        </div>
      </div>
      <div>
        <button id="btnDownload" class="secondary">アライン後のPDBをダウンロード</button>
      </div>
      <p class="muted">ヒント: ビューア内で <code class="kbd">R</code> を押すとカメラ位置がリセットされます。</p>
    </article>

    <footer class="muted" style="margin:2rem 0">
      <small>© 2025 — <a href="https://github.com/arose/ngl" target="_blank" rel="noreferrer">NGL.js</a> を使用。データは外部へ送信されません。</small>
    </footer>
  </main>

<script>
/******************** 共通ユーティリティ ********************/
function showError(msg){ const d=document.getElementById('err'); d.textContent = msg||''; }

/******************** PDB パーサ ********************/
function parsePDB(pdbText) {
  const atoms = []; // {name,resName,chainID,resSeq,iCode,x,y,z,element,line}
  const lines = pdbText.split(/\r?\n/);
  for (const line of lines) {
    if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
      const name = line.slice(12,16).trim();
      const resName = line.slice(17,20).trim();
      const chainID = line.slice(21,22).trim() || ' ';
      const resSeq = parseInt(line.slice(22,26));
      const iCode = line.slice(26,27).trim();
      const x = parseFloat(line.slice(30,38));
      const y = parseFloat(line.slice(38,46));
      const z = parseFloat(line.slice(46,54));
      let element = line.length >= 78 ? line.slice(76,78).trim() : '';
      if(!element){ const c = name.trim()[0]; element = (c && c.toUpperCase()!=='H') ? c.toUpperCase() : 'H'; }
      atoms.push({ name, resName, chainID, resSeq, iCode, x, y, z, element, line });
    }
  }
  return atoms;
}

/******************** セレクタ ********************/
function selectChainCA(atoms, chains) {
  const set = new Set(Array.isArray(chains)? chains : [chains]);
  const list = [];
  const byKey = new Map();
  for (const a of atoms) {
    if (chains && !set.has(a.chainID)) continue;
    if (a.name === 'CA') {
      const key = `${a.chainID}|${a.resSeq}:${a.iCode}`;
      const xyz = [a.x,a.y,a.z];
      list.push({ key, chainID:a.chainID, resSeq:a.resSeq, iCode:a.iCode, resName:a.resName, xyz });
      byKey.set(key, xyz);
    }
  }
  return { list, byKey };
}

function selectAtoms(atoms, chains, atomSet){
  const set = new Set(Array.isArray(chains)? chains : [chains]);
  const list=[]; const map=new Map();
  const isBB = (n)=> n==='N' || n==='CA' || n==='C' || n==='O';
  for(const a of atoms){
    if(chains && !set.has(a.chainID)) continue;
    if(atomSet==='ca' && a.name!=='CA') continue;
    if(atomSet==='bb' && !isBB(a.name)) continue;
    if(atomSet==='heavy' && a.element==='H') continue;
    const resKey = `${a.chainID}|${a.resSeq}:${a.iCode}`;
    const compKey = `${resKey}|${a.name}`;
    const xyz=[a.x,a.y,a.z];
    list.push({resKey, atomName:a.name, xyz});
    map.set(compKey, xyz);
  }
  return { list, map };
}

/******************** 配列アライン（CA用の簡易NW） ********************/
const threeToOne = { ALA:'A', ARG:'R', ASN:'N', ASP:'D', CYS:'C', GLU:'E', GLN:'Q', GLY:'G', HIS:'H', ILE:'I', LEU:'L', LYS:'K', MET:'M', PHE:'F', PRO:'P', SER:'S', THR:'T', TRP:'W', TYR:'Y', VAL:'V', SEC:'U', PYL:'O' };
function seqFromCA(list) { return list.map(r => (threeToOne[r.resName] || 'X')).join(''); }
function needlemanWunsch(a, b, {match=2, mismatch=-1, gap=-2}={}) {
  const n=a.length, m=b.length;
  const dp = Array.from({length:n+1},()=>Array(m+1).fill(0));
  const bt = Array.from({length:n+1},()=>Array(m+1).fill(0)); // 0:diag, 1:up, 2:left
  for(let i=1;i<=n;i++){ dp[i][0]=i*gap; bt[i][0]=1; }
  for(let j=1;j<=m;j++){ dp[0][j]=j*gap; bt[0][j]=2; }
  for(let i=1;i<=n;i++){
    for(let j=1;j<=m;j++){
      const scoreDiag = dp[i-1][j-1] + (a[i-1]===b[j-1]?match:mismatch);
      const scoreUp = dp[i-1][j] + gap;
      const scoreLeft = dp[i][j-1] + gap;
      const maxv = Math.max(scoreDiag, scoreUp, scoreLeft);
      dp[i][j]=maxv; bt[i][j] = (maxv===scoreDiag)?0:(maxv===scoreUp?1:2);
    }
  }
  let i=n, j=m; const A=[], B=[];
  while(i>0 || j>0){
    const move = bt[i][j];
    if (i>0 && j>0 && move===0){ A.push(a[i-1]); B.push(b[j-1]); i--; j--; }
    else if (i>0 && (j===0 || move===1)){ A.push(a[i-1]); B.push('-'); i--; }
    else { A.push('-'); B.push(b[j-1]); j--; }
  }
  return { a:A.reverse().join(''), b:B.reverse().join('') };
}

/******************** Kabsch ********************/
function meanVec(P){ const n=P.length; return [0,1,2].map(k=>P.reduce((s,p)=>s+p[k],0)/n); }
function subVec(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function matMul(A,B){ const out=[[0,0,0],[0,0,0],[0,0,0]]; for(let i=0;i<3;i++) for(let j=0;j<3;j++) for(let k=0;k<3;k++) out[i][j]+=A[i][k]*B[k][j]; return out; }
function matVec(A,v){ return [A[0][0]*v[0]+A[0][1]*v[1]+A[0][2]*v[2], A[1][0]*v[0]+A[1][1]*v[1]+A[1][2]*v[2], A[2][0]*v[0]+A[2][1]*v[1]+A[2][2]*v[2]]; }
function svd3x3(M){
  function transpose(A){ return [[A[0][0],A[1][0],A[2][0]],[A[0][1],A[1][1],A[2][1]],[A[0][2],A[1][2],A[2][2]]]; }
  function matMul3(A,B){ return matMul(A,B); }
  const Mt = transpose(M); const MtM = matMul3(Mt,M);
  function eigSym3(A){
    let V=[[1,0,0],[0,1,0],[0,0,1]]; let B=[[...A[0]],[...A[1]],[...A[2]]];
    for(let iter=0; iter<32; iter++){
      let p=0,q=1; let max=Math.abs(B[0][1]);
      const pairs=[[0,1],[0,2],[1,2]];
      for(const [i,j] of pairs){ const v=Math.abs(B[i][j]); if(v>max){max=v;p=i;q=j;} }
      if(max<1e-12) break;
      const app=B[p][p], aqq=B[q][q], apq=B[p][q];
      const phi=0.5*Math.atan2(2*apq, (aqq-app));
      const c=Math.cos(phi), s=Math.sin(phi);
      const Rp=[[1,0,0],[0,1,0],[0,0,1]]; Rp[p][p]=c; Rp[q][q]=c; Rp[p][q]=s; Rp[q][p]=-s;
      const Rt=[[1,0,0],[0,1,0],[0,0,1]]; Rt[p][p]=c; Rt[q][q]=c; Rt[p][q]=-s; Rt[q][p]=s;
      B = matMul3(matMul3(Rt,B),Rp);
      V = matMul3(V,Rp);
    }
    const vals=[B[0][0],B[1][1],B[2][2]]; return {vals, vecs:V};
  }
  const {vals, vecs} = eigSym3(MtM);
  const Svals = vals.map(v=> Math.sqrt(Math.max(0,v)) );
  const V = [[vecs[0][0],vecs[0][1],vecs[0][2]],[vecs[1][0],vecs[1][1],vecs[1][2]],[vecs[2][0],vecs[2][1],vecs[2][2]]];
  const Sinv = [[ Svals[0]?1/Svals[0]:0,0,0 ],[0,Svals[1]?1/Svals[1]:0,0],[0,0,Svals[2]?1/Svals[2]:0]];
  const U = matMul(matMul(M,V),Sinv);
  return {U, S:Svals, Vt: transpose(V)};
}
function kabsch(P, Q){
  const Pc = meanVec(P), Qc = meanVec(Q);
  const X = P.map(p=>subVec(p,Pc));
  const Y = Q.map(q=>subVec(q,Qc));
  const H=[[0,0,0],[0,0,0],[0,0,0]];
  for(let i=0;i<X.length;i++){
    const x=X[i], y=Y[i];
    H[0][0]+=x[0]*y[0]; H[0][1]+=x[0]*y[1]; H[0][2]+=x[0]*y[2];
    H[1][0]+=x[1]*y[0]; H[1][1]+=x[1]*y[1]; H[1][2]+=x[1]*y[2];
    H[2][0]+=x[2]*y[0]; H[2][1]+=x[2]*y[1]; H[2][2]+=x[2]*y[2];
  }
  const {U, Vt} = svd3x3(H);
  let R = matMul(Vt, [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]]);
  const det = R[0][0]*(R[1][1]*R[2][2]-R[1][2]*R[2][1]) - R[0][1]*(R[1][0]*R[2][2]-R[1][2]*R[2][0]) + R[0][2]*(R[1][0]*R[2][1]-R[1][1]*R[2][0]);
  if(det<0){ Vt[2][0]*=-1; Vt[2][1]*=-1; Vt[2][2]*=-1; R = matMul(Vt, [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]]); }
  const t = [ Qc[0] - (R[0][0]*Pc[0]+R[0][1]*Pc[1]+R[0][2]*Pc[2]),
              Qc[1] - (R[1][0]*Pc[0]+R[1][1]*Pc[1]+R[1][2]*Pc[2]),
              Qc[2] - (R[2][0]*Pc[0]+R[2][1]*Pc[1]+R[2][2]*Pc[2]) ];
  return {R,t};
}
function rmsd(A,B){ let s=0; for(let i=0;i<A.length;i++){ const dx=A[i][0]-B[i][0]; const dy=A[i][1]-B[i][1]; const dz=A[i][2]-B[i][2]; s+=dx*dx+dy*dy+dz*dz; } return Math.sqrt(s/A.length); }

/******************** マッチング（多チェーン対応） ********************/
function matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM, chainMap){
  const T=[]; const M=[];
  function pushPairsCA(mapT, mapM){
    const keys = [...mapT.keys()].filter(k=>mapM.has(k)).sort((a,b)=>{
      const [ca,ra]=a.split('|'); const [cb,rb]=b.split('|');
      const ai=parseInt(ra.split(':')[0]), bi=parseInt(rb.split(':')[0]);
      return ca.localeCompare(cb) || (ai-bi);
    });
    for(const k of keys){ T.push(mapT.get(k)); M.push(mapM.get(k)); }
  }
  function pushPairsAtoms(selT, selM){
    const keys = [...selT.map.keys()].filter(k=>selM.map.has(k)).sort((a,b)=>{
      const [ra,na]=a.split('|'); const [rb,nb]=b.split('|');
      const [ca, ia] = ra.split('|'); const [cb, ib] = rb.split('|');
      const ai=parseInt(ia.split(':')[0]), bi=parseInt(ib.split(':')[0]);
      return ca.localeCompare(cb) || (ai-bi) || na.localeCompare(nb);
    });
    for(const k of keys){ T.push(selT.map.get(k)); M.push(selM.map.get(k)); }
  }
  for(const [ct, cm] of chainMap){
    if(strategy==='resnum'){
      if(atomSet==='ca'){
        const mapT = new Map(caT.list.filter(r=>r.chainID===ct).map(r=>[`${r.chainID}|${r.resSeq}:${r.iCode}`, r.xyz]));
        const mapM = new Map(caM.list.filter(r=>r.chainID===cm).map(r=>[`${r.chainID}|${r.resSeq}:${r.iCode}`, r.xyz]));
        pushPairsCA(mapT, mapM);
      }else{
        const selT = selectAtoms(atomsT, [ct], atomSet);
        const selM = selectAtoms(atomsM, [cm], atomSet);
        pushPairsAtoms(selT, selM);
      }
    } else if (strategy==='index'){
      const lt = caT.list.filter(r=>r.chainID===ct);
      const lm = caM.list.filter(r=>r.chainID===cm);
      const n = Math.min(lt.length, lm.length);
      for(let i=0;i<n;i++){ T.push(lt[i].xyz); M.push(lm[i].xyz); }
    } else {
      const lt = caT.list.filter(r=>r.chainID===ct);
      const lm = caM.list.filter(r=>r.chainID===cm);
      const seqT = seqFromCA(lt), seqM = seqFromCA(lm);
      const aln = needlemanWunsch(seqT, seqM, {match:2, mismatch:-1, gap:-2});
      let iT=0, iM=0;
      for(let k=0;k<aln.a.length;k++){
        const a=aln.a[k], b=aln.b[k];
        if(a!=='-' && b!=='-'){ T.push(lt[iT].xyz); M.push(lm[iM].xyz); }
        if(a!=='-') iT++; if(b!=='-') iM++;
      }
    }
  }
  return {T,M, count:T.length};
}

/******************** 変換 & 表示 ********************/
function transformPDB(atoms, R, t){
  function fmt8(val){ return val.toFixed(3).toString().padStart(8,' '); }
  const out = [];
  for(const a of atoms){
    const v=[a.x,a.y,a.z];
    const tv=[ R[0][0]*v[0]+R[0][1]*v[1]+R[0][2]*v[2]+t[0],
               R[1][0]*v[0]+R[1][1]*v[1]+R[1][2]*v[2]+t[1],
               R[2][0]*v[0]+R[2][1]*v[1]+R[2][2]*v[2]+t[2] ];
    let line = a.line;
    line = line.substring(0,30) + fmt8(tv[0]) + fmt8(tv[1]) + fmt8(tv[2]) + line.substring(54);
    out.push(line);
  }
  out.push('END');
  return out.join('\n');
}
function renderNGL(divId, pdbText, color){
  const stage = new NGL.Stage(divId, { backgroundColor: '#ffffff' });
  stage.removeAllComponents();
  const blob = new Blob([pdbText], {type:'text/plain'});
  stage.loadFile(blob, {ext:'pdb'}).then(c=>{
    c.addRepresentation('cartoon', {color, roughness:1.0});
    c.autoView();
  });
  return stage;
}

/******************** 実行ハンドラ ********************/
let alignedPDBText='';
async function alignSubmit(ev){
  ev.preventDefault();
  showError('');
  try{
    const fd = new FormData(document.getElementById('form'));
    const targetFile = fd.get('pdb_target');
    const mobileFile = fd.get('pdb_mobile');
    if(!targetFile || !mobileFile){ showError('PDBファイルを選択してください'); return; }

    const chainT_in = (fd.get('chain_target')||'A').split(',').map(s=>s.trim()).filter(Boolean);
    const chainM_in = (fd.get('chain_mobile')||'A').split(',').map(s=>s.trim()).filter(Boolean);
    const mapMode = fd.get('chain_map_mode')||'auto2';
    const strategy = fd.get('match_strategy') || 'resnum';
    const atomSet = (fd.get('atom_set')||'bb');
    const minPairs = parseInt(fd.get('min_pairs')||'12');

    const targText = await targetFile.text();
    const mobText  = await mobileFile.text();
    const atomsT = parsePDB(targText);
    const atomsM = parsePDB(mobText);
    const caT = selectChainCA(atomsT, chainT_in);
    const caM = selectChainCA(atomsM, chainM_in);

    function attemptWithMap(chainMap){
      const {T,M,count} = matchPairs(strategy, caT, caM, atomSet, atomsT, atomsM, chainMap);
      if(count < Math.max(3,minPairs)) return {ok:false};
      const {R,t} = kabsch(M, T);
      const MT = M.map(v=> [ R[0][0]*v[0]+R[0][1]*v[1]+R[0][2]*v[2]+t[0],
                             R[1][0]*v[0]+R[1][1]*v[1]+R[1][2]*v[2]+t[1],
                             R[2][0]*v[0]+R[2][1]*v[1]+R[2][2]*v[2]+t[2] ]);
      const r = rmsd(MT, T);
      return {ok:true, R, t, count, rmsd:r};
    }

    let best = null; let usedMap = null;
    if(mapMode==='auto2' && chainT_in.length===2 && chainM_in.length===2){
      const maps = [ [[chainT_in[0], chainM_in[0]],[chainT_in[1], chainM_in[1]]],
                     [[chainT_in[0], chainM_in[1]],[chainT_in[1], chainM_in[0]]] ];
      for(const m of maps){ const res = attemptWithMap(m); if(res.ok && (!best || res.rmsd < best.rmsd)){ best = res; usedMap = m; } }
    } else {
      const zipped = chainT_in.map((c,i)=>[c, chainM_in[i]]).filter(p=>p[0]&&p[1]);
      const m = zipped.length ? zipped : [[chainT_in[0], chainM_in[0]]];
      const res = attemptWithMap(m); if(res.ok){ best=res; usedMap=m; }
    }

    if(!best){ showError('マッチ数が不足、またはチェーン対応が不正です。チェーン指定・戦略・原子集合を見直してください。'); return; }

    alignedPDBText = transformPDB(atomsM, best.R, best.t);
    document.getElementById('matched').textContent = best.count;
    document.getElementById('rmsd').textContent = best.rmsd.toFixed(3);
    document.getElementById('result').style.display = '';

    renderNGL('stageT', targText, 0x2196f3);
    renderNGL('stageM', alignedPDBText, 0xff7043);
  }catch(e){ console.error(e); showError('実行時エラー: ' + (e?.message||e)); }
}

// ダウンロード
const btn = document.getElementById('btnDownload');
btn.addEventListener('click', ()=>{
  if(!alignedPDBText){ alert('先にアラインメントを実行してください'); return; }
  const blob = new Blob([alignedPDBText], {type:'chemical/x-pdb'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'mobile_aligned.pdb';
  a.click();
  URL.revokeObjectURL(a.href);
});
</script>
</body>
</html>
